<!doctype html>
<html lang="ko" data-theme="{{SITE_THEME}}">

<head>
  <!-- @include partials/head-shared.html -->
  <title>J-S-04 정적 멤버(Static)와 상속(Inheritance) — {{SITE_NAME}}</title>
  <meta name="description" content="{{PAGE_DESCRIPTION}}" />
  <link rel="canonical" href="{{PAGE_URL}}" />
  <meta property="og:title" content="J-S-04 정적 멤버(Static)와 상속(Inheritance) — {{SITE_NAME}}" />
  <meta property="og:description" content="{{PAGE_DESCRIPTION}}" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="{{PAGE_URL}}" />
  <meta property="og:image" content="{{OG_IMAGE}}" />
  <meta property="article:section" content="{{ARTICLE_SECTION}}" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="alternate" type="application/rss+xml" title="{{SITE_NAME}}" href="/feed.xml" />
  {{POST_JSONLD}}
</head>

<body>
  <a class="u-sr-only u-sr-only--focusable" href="#main">본문 바로가기</a>
  <!-- @include partials/site-header.html -->

  <main id="main" class="l-reading" role="main">
    {{SERIES_NAV}}
    <!-- <nav class="c-breadcrumb" aria-label="breadcrumb">{{BREADCRUMB}}</nav> -->
    <article class="c-article u-flow" aria-labelledby="post-title">
      <header>
        {{SERIES_BADGE}}
        <h1 id="post-title">J-S-04 정적 멤버(Static)와 상속(Inheritance)</h1>
        <p class="c-article__meta">
          2025-12-27 <span class="c-article__meta-sep">|</span> {{BREADCRUMB}}
        </p>
      </header>
      <!--FM_BLOCK_START-->
<details class="c-fm" {{FM_OPEN_ATTR}}>
  <summary>글 정보</summary>
  <dl class="c-fm__list">
    <div class="c-fm__item">
      <dt>카테고리</dt>
      <dd>Programming/Java/Starter</dd>
    </div>
    <div class="c-fm__item">
      <dt>태그</dt>
      <dd><span class="c-fm__tag">Java</span><span class="c-fm__tag">Level1</span></dd>
    </div>
  </dl>
</details>
<hr class="c-fm__sep" />
<!--FM_BLOCK_END-->
<h2>1. 정적 멤버 (Static Member)</h2>
<p>정적 멤버는 객체지향인 자바에서 '객체 없는 세상'을 다루는 독특한 요소입니다.</p>
<h3>1.1. 개념과 특징</h3>
<ul>
<li><strong>독립적 존재</strong>: 인스턴스(객체) 생성과 무관하게 독립적으로 존재합니다.</li>
<li><strong>생성 시점</strong>: 프로그램 시작 후 해당 <strong>클래스가 로딩(Class Loading)되는 시점</strong>에 메모리에 딱 한 번 생성됩니다.</li>
<li><strong>공유 자원</strong>: 모든 인스턴스가 하나의 <code>static</code> 필드를 공유합니다.</li>
<li><strong>호출 관례</strong>: <code>참조변수.필드</code>보다는 <code>클래스명.필드</code>로 호출하는 것이 명확합니다. (예: <code>Math.PI</code>)</li>
<li><strong><code>this</code> 사용 불가</strong>: 객체가 생성되기도 전에 이미 존재하므로, '나 자신(Instance)'을 가리키는 <code>this</code> 키워드는 사용할 수 없습니다.</li>
</ul>
<h3>1.2. 심볼릭 상수 (Symbolic Constant)</h3>
<p><code>static</code>과 <code>final</code>을 조합하여 유지보수성과 효율성을 모두 잡는 패턴입니다.</p>
<ul>
<li><strong>가독성</strong>: <code>3.14</code> 같은 매직 넘버 대신 <code>PI</code>라는 이름을 부여합니다.</li>
<li><strong>메모리 효율</strong>: <code>static</code>으로 한 번만 할당하고, <code>final</code>로 불변성을 보장합니다.</li>
<li><strong>관례</strong>: 대문자와 언더바(<code>_</code>)를 사용합니다. (예: <code>MAX_VALUE</code>, <code>DEFAULT_TIMEOUT</code>)</li>
</ul>
<pre><code class="language-java">public class Constants {
    // 메모리에 1개만 존재하며, 수정 불가능한 상수
    public static final int MAX_user_COUNT = 100;
}
</code></pre>
<h3>1.3. 메모리 구조 (Deep Dive)</h3>
<ul>
<li><strong>위치</strong>: 정적 필드는 Heap이 아닌 <strong>Method Area (또는 Static Area)</strong>에 저장됩니다.</li>
<li><strong>GC 대상 아님</strong>: 프로그램 종료 시까지 유지되므로, 무분별한 <code>static</code> 남용은 메모리 누수의 원인이 될 수 있습니다.</li>
<li><strong>Tip (메서드의 비밀)</strong>:</li>
<ul>
<li>사실 <strong>모든 메서드(로직)</strong>는 <code>static</code>이든 아니든 <strong>Method Area에 한 번만 로딩</strong>되어 공유됩니다.</li>
<li>인스턴스 메서드는 단지 '숨겨진 파라미터(<code>this</code>)'를 넘겨받아 누구의 데이터를 처리할지 알 뿐, 코드 자체는 하나입니다.</li>
</ul>
</ul>
<h2>2. 상속 (Inheritance), 그리고 관계</h2>
<p>상속은 코드를 재사용하고 확장하기 위한 핵심 문법(<code>extends</code>)입니다.</p>
<h3>2.1. 관계의 정의 (is-a vs has-a)</h3>
<p>설계 시 가장 중요한 것은 두 객체 간의 관계를 정의하는 것입니다.</p>
<ol>
<li><strong>is-a 관계 (상속)</strong>: "~은 ~의 한 종류이다."</li>
<ul>
<li>자식 클래스는 부모 클래스를 포함하는 개념입니다.</li>
<li>예: <code>Man extends Mammal</code> (사람은 포유류다)</li>
</ul>
<li><strong>has-a 관계 (포함/조합)</strong>: "~은 ~을 가지고 있다."</li>
<ul>
<li>상속하지 않고, 클래스 내부에 <strong>다른 클래스를 멤버 변수로</strong> 가집니다.</li>
<li>예: <code>Car</code> 클래스 내부에 <code>Engine</code> 변수 존재 (자동차는 엔진을 가진다)</li>
</ul>
</ol>
<h3>2.2. 생성자의 연쇄 호출</h3>
<ul>
<li>자식 클래스를 <code>new</code>로 생성하면, 논리적으로 부모 클래스도 함께 초기화되어야 합니다.</li>
<li>자식 클래스 생성자의 <strong>맨 첫 줄</strong>에는 항상 <code>super()</code>가 생략되어 있으며, 이를 통해 부모의 생성자가 먼저 호출됩니다.</li>
</ul>
<pre><code class="language-java">class Parent {
    Parent() { System.out.println("부모 생성"); }
}
class Child extends Parent {
    Child() {
        // super(); // 컴파일러가 자동으로 삽입
        System.out.println("자식 생성");
    }
}
// 결과: "부모 생성" -&gt; "자식 생성"
</code></pre>
<h3>2.3. 추상자료형 (ADT)과 관점</h3>
<ul>
<li><strong>추상화</strong>: 내부는 복잡하게 구현(<code>@Override</code>)되어 있어도, 외부에서는 부모 타입의 단순한 인터페이스만 보고 사용합니다.</li>
<li><strong>은닉</strong>: "어떻게(How)" 구현했는지는 자식 클래스에 숨기고, "무엇을(What)" 하는지만 노출합니다.</li>
</ul>
<h3>2.4. 2차원적 코드 흐름</h3>
<p>상속을 사용하면 디버깅이나 코드 분석 시 시각이 달라져야 합니다.</p>
<ul>
<li><strong>1차원</strong>: 일반 코드는 위에서 아래로 순차 실행됩니다.</li>
<li><strong>2차원 (수직 이동)</strong>: 메서드를 호출하거나 변수를 찾을 때, 현재 클래스에 없으면 <strong>부모 클래스(위쪽)로 거슬러 올라가며 탐색</strong>합니다. 실행 흐름이 수평(시간)과 수직(계층)을 오가게 됩니다.</li>
</ul>
<h2>2.5 자식 클래스의 생성자: 호출과 실행의 역설</h2>
<p>상속 관계에서 가장 먼저 이해해야 할 부분은 바로 생성자의 동작 방식입니다. 자식 클래스의 인스턴스를 생성할 때, <strong>자식 클래스의 생성자가 코드상으로는 가장 먼저 호출되지만, 실제 실행은 가장 늦게 완료됩니다.</strong></p>
<p>이 순서는 반드시 기억해야 합니다. 호출은 '자식'부터 시작되지만, 초기화의 흐름은 부모 클래스로 거슬러 올라가 <strong>최상위 클래스(Object)부터 아래로 내려오며 실행</strong>되기 때문입니다.</p>
<p><img src="https://imgs.limc.dev/J/S/04/J-S-04-03.webp" /></p>
<h3>주의해야 할 필드 정의</h3>
<p>자식 클래스를 설계할 때 한 가지 원칙을 꼭 지켜야 합니다. 바로 <strong>"자식 클래스에서 부모 클래스의 필드를 절대 재정의하지 말 것"</strong> 입니다.</p>
<p>부모와 동일한 이름의 변수를 자식에서 다시 선언하는 것은 대부분 좋지 않은 설계이며, 의도치 않은 버그를 유발합니다.</p>
<p>이를 변수섀도잉이라고도 부릅니다.</p>
<blockquote><strong>변수 섀도잉(Variable Shadowing)</strong> <strong>변수 섀도잉</strong>은 상위 스코프(부모 클래스)에서 정의된 변수와 동일한 이름의 변수를 하위 스코프(자식 클래스)에서 다시 선언했을 때 발생합니다. 이 경우, 자식 클래스 내에서는 부모의 변수가 자식의 변수에 의해 "가려지는(Shadowed)" 현상이 나타납니다.</blockquote>
<p>상속 관계에서의 메모리 구조는 아래 그림을 참고하면 이해가 빠릅니다. <img src="https://imgs.limc.dev/J/S/04/J-S-04-01.webp" /></p>
<h3>현재와 미래의 대화</h3>
<p>부모와 자식 클래스 간의 관계를 시점의 관점에서 바라보면 흥미롭습니다. </p>
<p><strong>부모 클래스는 <code>현재</code> 작성되는 코드이고, 자식 클래스는 <code>미래</code>에 작성될 코드</strong>입니다.</p>
<p>따라서 우리는 항상 미래에 만들어질 파생(자식) 클래스를 고려하여 현재의 클래스를 설계해야 합니다.</p>
<p>다만, 상속에 상속이 꼬리를 무는 깊은 상속 구조는 유지 보수 측면에서 바람직하지 않으니 주의해야 합니다.</p>
<p><img src="https://imgs.limc.dev/J/S/04/J-S-04-02.webp" /></p>
<h2>2.6 super: 부모를 부르는 이름</h2>
<p><code>super</code>는 자식 클래스에서 부모 클래스를 지칭할 때 사용하는 키워드입니다.</p>
<p>주로 자식 클래스의 생성자 내부에서 부모 클래스의 생성자를 호출해야 할 때 <code>super()</code>와 같은 형태로 사용합니다.</p>
<p>이를 통해 부모 객체가 먼저 온전하게 초기화되도록 보장할 수 있습니다.</p>
<pre><code class="language-java">class Parent {
    String name;
    // 기본 생성자 없음 (매개변수가 있는 생성자만 존재)
    Parent(String name) { this.name = name; }
}

class Child extends Parent {
    int age;

    Child(String name, int age) {
        super(name); // [필수] 부모의 생성자를 명시적으로 호출해야 함!
        this.age = age;
    }
}
</code></pre>
<h2>2.7 메서드 재정의(Override): 확장의 핵심</h2>
<p>상속의 꽃은 바로 메서드 재정의(Overriding)입니다.</p>
<p>이는 <strong>부모 클래스가 가진 기존 메서드의 기능을 자식 클래스에서 대체하거나, 새로운 기능을 덧붙이는 것</strong>을 목적으로 합니다.</p>
<h3>실체(Instance)가 우선이다</h3>
<p>메서드 재정의에서 가장 중요한 규칙은 <strong>"실제 생성된 인스턴스가 우선"</strong> 이라는 점입니다.</p>
<p>변수의 타입이 부모 클래스(<code>Parent</code>)라고 할지라도, 실제 <code>new</code> 키워드로 생성한 인스턴스가 자식 클래스(<code>Child</code>)라면 실행 시에는 <strong>자식 클래스에서 재정의한 메서드가 호출</strong>됩니다.</p>
<p>물론, 자식 클래스가 메서드를 함부로 변경하지 못하게 하고 싶다면 <code>final</code> 키워드를 사용하여 재정의를 막을 수 있습니다.</p>
<pre><code class="language-java">class Parent {
    // final 키워드를 사용하여 자식 클래스에서 수정을 금지함
    public final void secureMethod() {
        System.out.println("이 메서드는 자식 클래스에서 재정의할 수 없습니다.");
    }

    public void generalMethod() {
        System.out.println("이 메서드는 재정의가 가능합니다.");
    }
}

class Child extends Parent {
    // 아래 주석을 해제하면 컴파일 에러가 발생합니다.
    /*
    @Override
    public void secureMethod() {
        System.out.println("변경 시도!");
    }
    */
}
</code></pre>
<h3>@Override 어노테이션의 활용</h3>
<p>재정의할 때는 반드시 <code>@Override</code> 어노테이션을 사용하는 습관을 들여야 합니다.</p>
<ul>
<li><strong>메타데이터:</strong> 코드에 대한 정보를 제공합니다.</li>
<li><strong>안전장치:</strong> 컴파일러에게 "이 메서드는 재정의된 것이다"라고 알립니다. 만약 메서드 이름이나 파라미터가 틀렸다면 컴파일러가 오류를 잡아주어 실수를 방지합니다.</li>
</ul>
<h3>프레임워크와 제어의 역전 (Called by Framework)</h3>
<p>앞서 언급했듯 재정의는 <strong>'미래'</strong>에 일어날 일을 미리 대비하는 것입니다.</p>
<p>부모 클래스(라이브러리나 프레임워크)는 전체적인 흐름만 제어하고, 구체적인 동작은 비워두거나 기본 동작만 정의해 둡니다.</p>
<p>이후 개발자가 자식 클래스에서 메서드를 재정의하면, 프레임워크가 정해진 시점에 이 메서드를 호출하게 됩니다. 이를 <strong>'Called by Framework'</strong>라고 합니다.</p>
<ul>
<li><strong>OnXXX() 메서드:</strong> 보통 <code>onCreate</code>, <code>onInit</code>과 같은 이름의 메서드들이 여기에 해당합니다.</li>
<li><strong>흐름의 확장:</strong> 부모 클래스가 구조와 흐름을 잡고, 자식 클래스는 그 흐름 속에서 자신만의 코드를 끼워 넣어 기능을 완성합니다.</li>
</ul>
<pre><code class="language-java">abstract class FrameworkBase {
    // 1. 전체적인 실행 흐름을 정의 (자식이 변경 못하게 final 사용)
    public final void start() {
        System.out.println("프레임워크가 준비를 시작합니다.");
        onInit();    // 자식이 구현한 초기화 로직 호출
        onCreate();  // 자식이 구현한 생성 로직 호출
        System.out.println("프레임워크가 실행을 완료했습니다.");
    }

    // 2. 자식이 재정의하여 기능을 끼워 넣을 메서드들 (Hook Method)
    protected abstract void onInit();
    protected abstract void onCreate();
}

class MyApp extends FrameworkBase {
    @Override
    protected void onInit() {
        System.out.println("[MyApp] 설정 파일을 로드합니다.");
    }

    @Override
    protected void onCreate() {
        System.out.println("[MyApp] 화면 UI를 생성합니다.");
    }
}
</code></pre>
    </article>
  </main>

  <!-- @include partials/site-footer.html -->
</body>

</html>